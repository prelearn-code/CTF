import gmpy2
from Crypto.Util.number import long_to_bytes, bytes_to_long

# ================= 题目数据 =================
P_n = 14057332139537395701238463644827948204030576528558543283405966933509944444681257521108769303999679955371474546213196051386802936343092965202519504111238572269823072199039812208100301939365080328518578704076769147484922508482686658959347725753762078590928561862163337382463252361958145933210306431342748775024336556028267742021320891681762543660468484018686865891073110757394154024833552558863671537491089957038648328973790692356014778420333896705595252711514117478072828880198506187667924020260600124717243067420876363980538994101929437978668709128652587073901337310278665778299513763593234951137512120572797739181693
P_F_n = 14057332139537395701238463644827948204030576528558543283405966933509944444681257521108769303999679955371474546213196051386802936343092965202519504111238572269823072199039812208100301939365080328518578704076769147484922508482686658959347725753762078590928561862163337382463252361958145933210306431342748775024099427363967321110127562039879018616082926935567951378185280882426903064598376668106616694623540074057210432790309571018778281723710994930151635857933293394780142192586806292968028305922173313521186946635709194350912242693822450297748434301924950358561859804256788098033426537956252964976682327991427626735740

Q_n = 20714298338160449749545360743688018842877274054540852096459485283936802341271363766157976112525034004319938054034934880860956966585051684483662535780621673316774842614701726445870630109196016676725183412879870463432277629916669130494040403733295593655306104176367902352484367520262917943100467697540593925707162162616635533550262718808746254599456286578409187895171015796991910123804529825519519278388910483133813330902530160448972926096083990208243274548561238253002789474920730760001104048093295680593033327818821255300893423412192265814418546134015557579236219461780344469127987669565138930308525189944897421753947
Q_E_D = 100772079222298134586116156850742817855408127716962891929259868746672572602333918958075582671752493618259518286336122772703330183037221105058298653490794337885098499073583821832532798309513538383175233429533467348390389323225198805294950484802068148590902907221150968539067980432831310376368202773212266320112670699737501054831646286585142281419237572222713975646843555024731855688573834108711874406149540078253774349708158063055754932812675786123700768288048445326199880983717504538825498103789304873682191053050366806825802602658674268440844577955499368404019114913934477160428428662847012289516655310680119638600315228284298935201
Ciphertext = 40855937355228438525361161524441274634175356845950884889338630813182607485910094677909779126550263304194796000904384775495000943424070396334435810126536165332565417336797036611773382728344687175253081047586602838685027428292621557914514629024324794275772522013126464926990620140406412999485728750385876868115091735425577555027394033416643032644774339644654011686716639760512353355719065795222201167219831780961308225780478482467294410828543488412258764446494815238766185728454416691898859462532083437213793104823759147317613637881419787581920745151430394526712790608442960106537539121880514269830696341737507717448946962021
E_final = 65537

# ================= 核心工具函数 =================

def solve_quadratic(a, b, c):
    """
    解方程 ax^2 + bx + c = 0
    返回两个整数根 (x1, x2)，如果无整数解则返回 None
    """
    delta_sq = b*b - 4*a*c
    if delta_sq < 0:
        return None
    
    # 强制使用 mpz 类型进行开方
    delta, exact = gmpy2.iroot(gmpy2.mpz(delta_sq), 2)
    
    if not exact:
        return None
        
    x1 = (-b - delta) // (2*a)
    x2 = (-b + delta) // (2*a)
    return x1, x2

def recover_pq(n, phi):
    """
    已知 n, phi，恢复 p, q
    p+q = n - phi + 1
    x^2 - (p+q)x + n = 0
    """
    n = gmpy2.mpz(n)
    phi = gmpy2.mpz(phi)
    sum_pq = n - phi + 1
    
    roots = solve_quadratic(1, -sum_pq, n)
    if roots:
        p, q = roots
        # 验证是否正确
        if p * q == n:
            return sorted([p, q]) # 返回 [小, 大]
    return None

# ================= 1. 恢复 _P =================
print("[*] 正在恢复 P ...")
res_p = recover_pq(P_n, P_F_n)
if not res_p:
    print("[-] P 恢复失败")
    exit()
    
p1, q1 = res_p
# 计算 _P
factor2_p = 2021 * p1 + 2020 * q1
_P = gmpy2.next_prime(factor2_p)
print(f"    [+] _P 恢复成功 (长度: {len(str(_P))} 位)")


# ================= 2. 恢复 _Q (带爆破 k) =================
print("[*] 正在恢复 Q ...")
Q_n = gmpy2.mpz(Q_n)
Q_E_D = gmpy2.mpz(Q_E_D)

# 估算 k，可能稍微有偏差，所以我们要搜索
k_base = Q_E_D // Q_n
print(f"    估算 k 基准值: {k_base}")

p2, q2 = None, None

# 尝试在 k_base 附近搜索 (通常误差在 0~100 之间)
for offset in range(0, 1000):
    k_guess = k_base + offset
    if k_guess == 0: continue
    
    # phi = (ed - 1) / k
    if (Q_E_D - 1) % k_guess != 0:
        continue
        
    phi_guess = (Q_E_D - 1) // k_guess
    
    # 尝试解方程
    res = recover_pq(Q_n, phi_guess)
    if res:
        p2, q2 = res
        print(f"    [+] 找到正确的 k: {k_guess}")
        print(f"    [+] p2, q2 恢复成功")
        break

if not p2:
    print("[-] Q 恢复失败，未能找到正确的 k")
    exit()

# 计算 _Q
factor2_q = abs(2021 * p2 - 2020 * q2)
_Q = gmpy2.next_prime(factor2_q)
print(f"    [+] _Q 恢复成功 (长度: {len(str(_Q))} 位)")


# ================= 3. 解密 =================
print("[*] 正在解密 Flag ...")
N_final = _P * _Q
phi_final = (_P - 1) * (_Q - 1)
D_final = gmpy2.invert(E_final, phi_final)

m = pow(Ciphertext, D_final, N_final)
flag_bytes = long_to_bytes(m)

print("\n" + "="*50)
# 使用 errors='replace' 防止因非打印字符报错，实际上如果解密正确应该是纯文本
print(f"FLAG: {flag_bytes.decode(errors='replace')}")
print("="*50)