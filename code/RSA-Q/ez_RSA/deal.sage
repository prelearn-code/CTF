import binascii
from Crypto.Util.number import long_to_bytes

def solve():
    # ================= 0. 题目数据 =================
    num3_val = 1.36557212221826657073387899060669771982679822943621690677450888408226656788387273887547841291114809989272635809810564202247340711087479554863446719786359395466961253205133910506682801159622545780721946115442033391600881399634390008053822158098121985270501317972263356522400827768601773721146954464269212959784543085
    n_val = 85105083975491693151454182116844944807066048677068373328227644321539783064315677834754866742549592569194223084173286381150626593510265361114796714226058887906219454795525438819082646860141163940340082006344850825956811992304447978369108606993344902286569100146695092703383844402883938506877787042873586279543
    c_val = 8090472119640930864901421058741085326954308673260202542020919764880488559370287585797498390920330336595858609617432370825503480936376306766495089200286004922821787548265246289552343468177624634434613746605553770994437785042510225956023382347023663125411103947669109085411939772215657220674436476279268458980
    n2_val = 101642316595332652021348165259853423287787139517550249986161819826180514401858258316466101056877182367161299111697465439636861942636526396547011727147471566130633614685728563576613692851860684686033186826342178072882901576159305747639645374751566751967096281105148714033096611618024355982220235949274576036321
    e1_val = 1630
    e2_val = 1866
    c1_val = 8857135083997055103287497833179378469532619748945804429057682575070405217145941944821968708809563240261403711644389684947851643865895254406194464015430673347359589677809515117412321862622147634752091324365628790687343748145339949310696116239361890881096088375070083053010564890401663562726144984405628773323
    c2_val = 44531030636557714647477473185500183066851251320453194953972504422367649302810396344051696851757189817391648356459225688318373454949578822468293099948132700460437006478679492801335689493431764882835346904225119630026545592437198370606462285405519745361570058335573353886454277790277663038008240372746639859253

    # ================= Stage 1: 连分数还原 num1, num2 =================
    print("[+] Stage 1: Recovering num1 and num2...")

    # 使用高精度实数域
    ring = RealField(1050)
    num3 = ring(num3_val)

    # 连分数展开
    cf = continued_fraction(num3)
    num1 = 0
    num2 = 0

    for convergent in cf.convergents():
        numerator = convergent.numerator()
        denominator = convergent.denominator()
        
        # num1 和 num2 都是 512 位
        if numerator.nbits() == 512 and denominator.nbits() == 512:
            num1 = int(numerator)
            num2 = int(denominator)
            print(f"    Found num1: {num1}")
            print(f"    Found num2: {num2}")
            break

    if num1 == 0:
        print("[-] Failed to recover num1/num2")
        return

    # ================= Stage 2: 多项式 GCD 恢复 p =================
    print("[+] Stage 2: Recovering p via Custom Polynomial GCD...")

    # 定义模 n2 的多项式环
    R.<x> = PolynomialRing(Zmod(n2_val))

    # 构造两个多项式: (x + num1)^e1 - c1 = 0
    f1 = (x + num1)^e1_val - c1_val
    f2 = (x + num2)^e2_val - c2_val

    # --- 自定义 GCD 函数 (解决 NotImplementedError) ---
    def pgcd(a, b):
        while b:
            a, b = b, a % b
            # 将多项式首项系数归一化 (Monic)，防止系数膨胀
            if b:
                b = b.monic()
        return a.monic()
    # -----------------------------------------------

    # 计算 GCD
    g = pgcd(f1, f2)
    
    # g 应该是 x + p 或者 x - p 的形式
    # 提取常数项，取负数得到 p
    p_recovered = int(-g.constant_coefficient())

    print(f"    Recovered p: {p_recovered}")

    # 简单验证
    if n_val % p_recovered == 0:
        print("    [Success] p is correct.")
    else:
        print("    [Fail] p is incorrect.")
        return

    # ================= Stage 3: RSA 解密 =================
    print("[+] Stage 3: Decrypting RSA...")

    p = p_recovered
    q = n_val // p
    phi = (p - 1) * (q - 1)
    e = 65537
    
    # 求私钥 d
    d = inverse_mod(e, phi)
    
    # 解密 m
    m = power_mod(c_val, d, n_val)
    
    # 转换为 Flag
    try:
        flag = long_to_bytes(int(m))
        print("\n" + "="*50)
        print(f"FLAG: {flag.decode()}")
        print("="*50 + "\n")
    except Exception as e:
        print(f"[-] Decryption failed: {e}")

# 执行主函数
solve()