import gmpy2
from Crypto.Util.number import long_to_bytes, inverse

# ================= 题目数据 =================
P_p = 206027926847308612719677572554991143421
P_factor = 213671742765908980787116579976289600595864704574134469173111790965233629909513884704158446946409910475727584342641848597858942209151114627306286393390259700239698869487469080881267182803062488043469138252786381822646126962323295676431679988602406971858136496624861228526070581338082202663895710929460596143281673761666804565161435963957655012011051936180536581488499059517946308650135300428672486819645279969693519039407892941672784362868653243632727928279698588177694171797254644864554162848696210763681197279758130811723700154618280764123396312330032986093579531909363210692564988076206283296967165522152288770019720928264542910922693728918198338839

Q_1 = 103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521
Q_2 = 151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743
sub_Q = 168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651

Ciphertext = 1709187240516367141460862187749451047644094885791761673574674330840842792189795049968394122216854491757922647656430908587059997070488674220330847871811836724541907666983042376216411561826640060734307013458794925025684062804589439843027290282034999617915124231838524593607080377300985152179828199569474241678651559771763395596697140206072537688129790126472053987391538280007082203006348029125729650207661362371936196789562658458778312533505938858959644541233578654340925901963957980047639114170033936570060250438906130591377904182111622236567507022711176457301476543461600524993045300728432815672077399879668276471832
e = 65537

# --- 辅助函数：获取上一个素数 ---
def get_prev_prime(n):
    curr = n - 1
    if curr % 2 == 0:
        curr -= 1
    while True:
        if gmpy2.is_prime(curr):
            return curr
        curr -= 2

def solve():
    print("[*] 正在恢复 _P ...")
    # 1. 恢复 P 列表 (P[0]...P[16])
    P_list = [0] * 17
    P_list[9] = P_p

    # 向前推导 P[8] 到 P[0]
    for i in range(9, 0, -1):
        P_list[i-1] = get_prev_prime(P_list[i])
    
    # 向后推导 P[10] 到 P[16]
    for i in range(9, 16):
        P_list[i+1] = gmpy2.next_prime(P_list[i])

    # 2. 计算 n 和 phi_n
    n_val = 1
    phi_n = 1
    for p_item in P_list:
        n_val *= p_item
        phi_n *= (p_item - 1)
    
    # 3. 恢复 p
    # factor = p^e mod n_val
    d_p = inverse(e, phi_n)
    p_recovered = pow(P_factor, d_p, n_val)
    
    _P = gmpy2.next_prime(p_recovered)
    print(f"    [+] _P 恢复成功: {_P}")

    # ================================
    
    print("[*] 正在恢复 _Q ...")
    # 4. 恢复 Q
    # Q = sub_Q ^ Q_2 % Q_1
    Q = pow(sub_Q, Q_2, Q_1)
    _Q = gmpy2.next_prime(Q)
    print(f"    [+] _Q 恢复成功: {_Q}")

    # ================================
    
    print("[*] 正在解密 Flag ...")
    # 5. 解密
    N_final = _P * _Q
    phi_final = (_P - 1) * (_Q - 1)
    
    try:
        d_final = inverse(e, phi_final)
        m = pow(Ciphertext, d_final, N_final)
        flag = long_to_bytes(m)
        print("\n" + "="*50)
        print(f"FLAG: {flag.decode()}")
        print("="*50 + "\n")
    except Exception as ex:
        print(f"[-] 解密出错: {ex}")

if __name__ == "__main__":
    solve()