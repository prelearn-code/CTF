import gmpy2
from Crypto.Util.number import long_to_bytes

def solve():
    # ================= 数据输入 =================
    A_val = 2683349182678714524247469512793476009861014781004924905484127480308161377768192868061561886577048646432382128960881487463427414176114486885830693959404989743229103516924432512724195654425703453612710310587164417035878308390676612592848750287387318129424195208623440294647817367740878211949147526287091298307480502897462279102572556822231669438279317474828479089719046386411971105448723910594710418093977044179949800373224354729179833393219827789389078869290217569511230868967647963089430594258815146362187250855166897553056073744582946148472068334167445499314471518357535261186318756327890016183228412253724
    n_val = 117930806043507374325982291823027285148807239117987369609583515353889814856088099671454394340816761242974462268435911765045576377767711593100416932019831889059333166946263184861287975722954992219766493089630810876984781113645362450398009234556085330943125568377741065242183073882558834603430862598066786475299918395341014877416901185392905676043795425126968745185649565106322336954427505104906770493155723995382318346714944184577894150229037758434597242564815299174950147754426950251419204917376517360505024549691723683358170823416757973059354784142601436519500811159036795034676360028928301979780528294114933347127
    c_val = 41971850275428383625653350824107291609587853887037624239544762751558838294718672159979929266922528917912189124713273673948051464226519605803745171340724343705832198554680196798623263806617998072496026019940476324971696928551159371970207365741517064295956376809297272541800647747885170905737868568000101029143923792003486793278197051326716680212726111099439262589341050943913401067673851885114314709706016622157285023272496793595281054074260451116213815934843317894898883215362289599366101018081513215120728297131352439066930452281829446586562062242527329672575620261776042653626411730955819001674118193293313612128
    
    A = gmpy2.mpz(A_val)
    n = gmpy2.mpz(n_val)
    c = gmpy2.mpz(c_val)

    # 1. 计算 y
    # y 约为 A 的 316 次方根
    y_approx, _ = gmpy2.iroot(A, 316)
    y = int(y_approx)
    
    print(f"[+] Found potential y: {y}")
    
    # 2. 爆破 x
    # x 必须整除 y+1
    target_num = y + 1
    factors = []
    # 找因子
    for i in range(1, int(target_num**0.5) + 1):
        if target_num % i == 0:
            factors.append(i)
            factors.append(target_num // i)
    
    real_x = None
    
    print(f"[*] Checking {len(factors)} candidates for x...")
    
    for x_cand in factors:
        if x_cand == 0: continue
        
        # 代入公式验证 A
        # A = (((y%x)**5)%(x%y))**2019 + y**316 + (y+1)/x
        
        try:
            term1_base = (pow(y % x_cand, 5)) % (x_cand % y)
            term1 = pow(term1_base, 2019)
            term2 = pow(y, 316)
            term3 = (y + 1) // x_cand
            
            calc_A = term1 + term2 + term3
            
            if calc_A == A:
                real_x = x_cand
                print(f"[+] Found correct x: {real_x}")
                break
        except ZeroDivisionError:
            continue
            
    if real_x is None:
        print("[-] Failed to find x.")
        return

    # 3. 求解 z 和 p, q
    # n ≈ z^2 * x * y
    # z ≈ sqrt(n / (x*y))
    product_xy = real_x * y
    z_approx = gmpy2.isqrt(n // product_xy)
    
    # q 是 z 的下一个素数
    q = gmpy2.next_prime(z_approx)
    
    if n % q == 0:
        p = n // q
        print("[+] Factorization Successful!")
        print(f"    p: {p}")
        print(f"    q: {q}")
    else:
        # 也许 q 是 z 之前的素数？或者 z 估算偏差？
        # 尝试微调
        print("[-] Direct factorization failed, searching near z...")
        # (通常 next_prime 就够了，除非 z_approx 偏大)
        return

    # 4. RSA 解密
    phi = (p - 1) * (q - 1)
    e = 65537
    d = gmpy2.invert(e, phi)
    m = pow(c, d, n)
    
    print(f"[+] Flag: {long_to_bytes(m).decode()}")

if __name__ == '__main__':
    solve()