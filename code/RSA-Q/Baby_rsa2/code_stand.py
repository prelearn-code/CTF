import gmpy2
from Crypto.Util.number import long_to_bytes, isPrime

# 题目给出的数据
e = 0x10001
d = 19275778946037899718035455438175509175723911466127462154506916564101519923603308900331427601983476886255849200332374081996442976307058597390881168155862238533018621944733299208108185814179466844504468163200369996564265921022888670062554504758512453217434777820468049494313818291727050400752551716550403647148197148884408264686846693842118387217753516963449753809860354047619256787869400297858568139700396567519469825398575103885487624463424429913017729585620877168171603444111464692841379661112075123399343270610272287865200880398193573260848268633461983435015031227070217852728240847398084414687146397303110709214913
c = 5382723168073828110696168558294206681757991149022777821127563301413483223874527233300721180839298617076705685041174247415826157096583055069337393987892262764211225227035880754417457056723909135525244957935906902665679777101130111392780237502928656225705262431431953003520093932924375902111280077255205118217436744112064069429678632923259898627997145803892753989255615273140300021040654505901442787810653626524305706316663169341797205752938755590056568986738227803487467274114398257187962140796551136220532809687606867385639367743705527511680719955380746377631156468689844150878381460560990755652899449340045313521804

def solve():
    # 1. 计算 e * d - 1，这是 k * phi(n) 的倍数
    X = e * d - 1
    
    # 2. 遍历可能的 k
    # 因为 e 比较小，k 的范围通常在 1 到 e 之间
    for k in range(1, e + 1):
        if X % k == 0:
            phi_candidate = X // k
            
            # 3. 尝试根据 phi 恢复 p
            # 因为 phi = (p-1)(q-1) 且 q 是 p 的下一个素数，
            # 此时 p * q 略大于 p^2，phi 略大于 p^2（除非是孪生素数，那时phi略小于p^2）
            # 所以 p 应该在 sqrt(phi) 附近。
            
            p_approx = gmpy2.isqrt(phi_candidate)
            
            # 我们在 p_approx 附近搜索 p
            # 通常 p 会比 sqrt(phi) 稍微小一点点（当素数间隙 > 2 时）
            # 我们先尝试把 p_approx 当作起点，向下找素数
            
            p_curr = p_approx
            # 简单搜寻范围，素数密度很高，循环几次就能找到
            for _ in range(5000): 
                # 确保 p_curr 是素数
                if isPrime(int(p_curr)):
                    p = int(p_curr)
                    # 根据题目逻辑计算对应的 q
                    q = int(gmpy2.next_prime(p))
                    
                    # 验证是否符合 phi 的定义
                    if (p - 1) * (q - 1) == phi_candidate:
                        print(f"[+] Found k = {k}")
                        print(f"[+] Found p = {p}")
                        print(f"[+] Found q = {q}")
                        
                        # 4. 解密
                        n = p * q
                        m = pow(c, d, n)
                        flag = long_to_bytes(m)
                        print(f"\nFlag: {flag.decode()}")
                        return

                # 向下搜索
                p_curr -= 1

solve()