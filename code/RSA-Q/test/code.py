import gmpy2
import math
from Crypto.Util.number import long_to_bytes, inverse, sieve_base
from tqdm import tqdm

# ================= 题目数据 =================
n = 32849718197337581823002243717057659218502519004386996660885100592872201948834155543125924395614928962750579667346279456710633774501407292473006312537723894221717638059058796679686953564471994009285384798450493756900459225040360430847240975678450171551048783818642467506711424027848778367427338647282428667393241157151675410661015044633282064056800913282016363415202171926089293431012379261585078566301060173689328363696699811123592090204578098276704877408688525618732848817623879899628629300385790344366046641825507767709276622692835393219811283244303899850483748651722336996164724553364097066493953127153066970594638491950199605713033004684970381605908909693802373826516622872100822213645899846325022476318425889580091613323747640467299866189070780620292627043349618839126919699862580579994887507733838561768581933029077488033326056066378869170169389819542928899483936705521710423905128732013121538495096959944889076705471928490092476616709838980562233255542325528398956185421193665359897664110835645928646616337700617883946369110702443135980068553511927115723157704586595844927607636003501038871748639417378062348085980873502535098755568810971926925447913858894180171498580131088992227637341857123607600275137768132347158657063692388249513
c = 26308018356739853895382240109968894175166731283702927002165268998773708335216338997058314157717147131083296551313334042509806229853341488461087009955203854253313827608275460592785607739091992591431080342664081962030557042784864074533380701014585315663218783130162376176094773010478159362434331787279303302718098735574605469803801873109982473258207444342330633191849040553550708886593340770753064322410889048135425025715982196600650740987076486540674090923181664281515197679745907830107684777248532278645343716263686014941081417914622724906314960249945105011301731247324601620886782967217339340393853616450077105125391982689986178342417223392217085276465471102737594719932347242482670320801063191869471318313514407997326350065187904154229557706351355052446027159972546737213451422978211055778164578782156428466626894026103053360431281644645515155471301826844754338802352846095293421718249819728205538534652212984831283642472071669494851823123552827380737798609829706225744376667082534026874483482483127491533474306552210039386256062116345785870668331513725792053302188276682550672663353937781055621860101624242216671635824311412793495965628876036344731733142759495348248970313655381407241457118743532311394697763283681852908564387282605279108
e = 0x10001

def whitebox_p_minus_1(n):
    """
    针对性攻击：直接使用 sieve_base 中的素数
    """
    print(f"[*] sieve_base range: {sieve_base[0]} to {sieve_base[-1]} (Total: {len(sieve_base)})")
    
    a = 2
    x = a
    
    # 我们知道 p-1 是由 sieve_base 中的素数乘积组成的
    # 所以我们遍历 sieve_base 中的每一个素数
    # 并为了处理重复因子（如 2^100），给每个素数加上一个足够大的指数
    # 2048 位数的最大幂次 log(2^2048, base=2) = 2048
    
    limit = 2048 # 指数上限，足够覆盖所有幂次
    
    print("[*] Performing Whitebox p-1 attack...")
    for p_factor in tqdm(sieve_base):
        # 计算需要的幂次 k，使得 p_factor^k < 2^2048
        # 其实简单粗暴一点，让指数能覆盖2048bit即可
        # 这里为了效率，计算一下大致的 k
        k = int(math.log(2**limit, p_factor))
        
        # 核心：x = x^(p_factor^k) mod n
        # 这样既覆盖了该素数，也覆盖了它的幂次
        exp = pow(p_factor, k)
        x = pow(x, exp, n)
    
    # 循环结束后检查 GCD
    d = gmpy2.gcd(x - 1, n)
    if 1 < d < n:
        return d
    return None

# 1. 分解 N
p = whitebox_p_minus_1(n)

if p:
    q = n // p
    print("\n[+] Factorization Successful!")
    print(f"    p: {p}")
    
    # 2. RSA 解密
    phi = (p - 1) * (q - 1)
    d = gmpy2.invert(e, phi)
    m = pow(c, d, n)
    
    flag = long_to_bytes(m)
    print("\n" + "="*50)
    print(f"FLAG: {flag.decode()}")
    print("="*50 + "\n")
else:
    print("[-] Attack failed. Something is weird about the environment.")