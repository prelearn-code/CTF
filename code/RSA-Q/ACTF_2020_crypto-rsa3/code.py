from Crypto.Util.number import long_to_bytes,isPrime,inverse
import gmpy2

# 其中，p,q十分接近

n = 177606504836499246970959030226871608885969321778211051080524634084516973331441644993898029573612290095853069264036530459253652875586267946877831055147546910227100566496658148381834683037366134553848011903251252726474047661274223137727688689535823533046778793131902143444408735610821167838717488859902242863683
c = 1457390378511382354771000540945361168984775052693073641682375071407490851289703070905749525830483035988737117653971428424612332020925926617395558868160380601912498299922825914229510166957910451841730028919883807634489834128830801407228447221775264711349928156290102782374379406719292116047581560530382210049
e=65537

p_start = int(gmpy2.isqrt(n))
p = 0
q = 0
for i in range(p_start,p_start+1000):
    if(i%2 == 1):
        if(isPrime(i)):
            if(n % i == 0):
                p = i
                q = n // p
                print("找到了p,q")
                break

print(p)
print(q)
phi = (p-1)*(q-1)
d = inverse(e,phi)
m = pow(c,d, n)

print(long_to_bytes(m))