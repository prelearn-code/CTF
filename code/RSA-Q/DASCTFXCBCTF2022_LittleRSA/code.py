import gmpy2
from Crypto.Util.number import long_to_bytes, inverse

# ================= 题目数据 =================
N = 19351301035801508116955552063316327463227928638319284082504070745230119792307421099534903837766317639913937954784857576991401214861067471772614753337821871108189780331081099041824669243928056765115068764246765680962348646383991303828426125303844394268682191775232611288039200316595279055408827296256289143602827525373267536643865729646353071637054367702218515803980122435811129935450486950137279824491461041391572264371799797200331838690523349105589985032730668315787318829244743317257793753147209875458127340875400367081865762286565978620979196410411241442894450955280237513249393612603560410291825805553536595543937
g = 101172011079013273946711882340439823149055809449035744718659818796135714101721641190114954130041477714466321498903210220694435354795744225843314447645623337668697058127975104586375292636080114347294697007231487782548846095107329445479367324424672776003899748234353857872627585595343736452088156885081907758727085723312506489549364721644636251780350312413098132506051531311685636921117457469745637347738336829350634994271419554741425590636953154753970902976959308323838617091060754826727417688836026597614894745348808019654100196615719730109909578899299246848916182034705259206906552769087038179288139086772719994577168184701096922291610523676039127012518100023765548552210944426749474888311751069936144583375194023227887848704267587915237057432609663328145608194550736074250822416779448467084842127165553649513397606464059847361880649213934069715996589751778384513724306521043255299443480482640183740131563318058454711913397533436985618182923646192481486120942073719321372236539019107909910597047133371708017755744495134116771999521953654596632221519266339372439452558083199640035069852530373510758859460350025736629801086757717838159774542506755335660607766677992105601518694405113552321342152041808586187181800679845672788746273313
n = 90106928919727272173474070618911951313216606598108495724382284361415375454490594410306345748069424740100772955015304592942129026096113424198209327375124576666577469761124470792842854884924199449996929134613382626394351988541980388358156143332979538058465890179760337315789398915560641465656968797050755849799
c = 51609249982849856103564442566936515708380814106997783395400669324617748952940831076546581735494963467680719842859574144530848473300102236821201997786375946601413660428461473204032985053128283751860315027843200214217715401391736262811016964783589439740884991543059175666298728428567481043422497862838127903980
e = 65537

# ================= 2维格规约算法 (Gaussian Reduction) =================
def gaussian_reduction(v1, v2):
    """
    对两个二维向量进行高斯规约 (类似 2D LLL)
    v1, v2 是形如 (x, y) 的元组或列表
    """
    def dot(u, v):
        return u[0]*v[0] + u[1]*v[1]
    
    def norm_sq(v):
        return v[0]*v[0] + v[1]*v[1]
    
    # 保证 |v1| <= |v2|
    if norm_sq(v2) < norm_sq(v1):
        v1, v2 = v2, v1
        
    while True:
        # 计算投影系数 mu = round( (v1 . v2) / |v1|^2 )
        # 使用整数运算代替浮点数以保证精度
        # round(a/b) = floor((a + b/2) / b) = (2a + b) // 2b
        numerator = 2 * dot(v1, v2) + norm_sq(v1) # 这里的逻辑稍微简化处理
        denominator = 2 * norm_sq(v1)
        
        # 更加稳健的 round 实现
        # mu = int(round( dot(v1, v2) / norm_sq(v1) ))
        # 为了避免浮点误差，使用整数除法实现 round
        d_prod = dot(v1, v2)
        d_norm = norm_sq(v1)
        
        # q = round(d_prod / d_norm)
        # q = (2 * d_prod + d_norm) // (2 * d_norm) if d_prod >= 0 ...
        # 简单写法：
        mu = (d_prod + d_norm // 2) // d_norm
        
        if mu == 0:
            return v1, v2
            
        # v2 = v2 - mu * v1
        new_v2_0 = v2[0] - mu * v1[0]
        new_v2_1 = v2[1] - mu * v1[1]
        v2 = (new_v2_0, new_v2_1)
        
        if norm_sq(v2) < norm_sq(v1):
            v1, v2 = v2, v1
        else:
            return v1, v2

def solve():
    # 构造格基向量
    # M = [[1, g], [0, N]]
    # 对应向量 v1 = (1, g), v2 = (0, N)
    v1 = (1, g)
    v2 = (0, N)
    
    print("[*] Starting Gaussian Lattice Reduction...")
    u, v = gaussian_reduction(v1, v2)
    
    # 规约后的向量 u = (x, y)
    # 我们期望 y = p (或者 -p)
    # 且 x = s^2
    
    print(f"[*] Reduced vector u: {u}")
    print(f"[*] Reduced vector v: {v}")
    
    # 检查向量的第二分量是否为 p
    candidates = [abs(u[1]), abs(v[1])]
    
    p = None
    for cand in candidates:
        if cand > 1 and n % cand == 0:
            p = cand
            break
            
    if p:
        print(f"\n[+] Found factor p: {p}")
        q = n // p
        
        # RSA 解密
        phi = (p - 1) * (q - 1)
        d = inverse(e, phi)
        m = pow(c, d, n)
        flag = long_to_bytes(m)
        print(f"[+] Flag: {flag.decode()}")
    else:
        print("[-] Failed to find p using Gaussian Reduction.")

if __name__ == "__main__":
    solve()