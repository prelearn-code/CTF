

# This file was *autogenerated* from the file code.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_4 = Integer(4); _sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_8 = Integer(8); _sage_const_30 = Integer(30); _sage_const_1 = Integer(1); _sage_const_20 = Integer(20); _sage_const_100 = Integer(100)
import base64
from Crypto.Util.number import long_to_bytes

def solve_stego(rsa_output):
    print("[*] 检测到 Base64 隐写，开始提取...")
    
    # 1. 按行分割
    lines = rsa_output.strip().split(b'\n')
    
    bin_str = ""
    base64_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    
    for line in lines:
        line = line.strip()
        if not line: continue
        
        # 转换为字符串处理
        s = line.decode()
        
        # 2. 判断 Padding 数量，提取隐写位
        if s.endswith("=="):
            # 2个等号，说明最后剩 1 个字节 (8bit)，编码成 2 个字符 (12bit)
            # 也就意味着隐写了 12 - 8 = 4 bit
            last_char = s[-_sage_const_3 ] # 倒数第三个字符是最后一个有效编码字符 (== 是最后两个)
            # 查找该字符在 Base64 表中的索引
            char_idx = base64_chars.index(last_char)
            # 取低 4 位
            bits = f"{char_idx:06b}"[-_sage_const_4 :]
            bin_str += bits
            
        elif s.endswith("="):
            # 1个等号，说明最后剩 2 个字节 (16bit)，编码成 3 个字符 (18bit)
            # 也就意味着隐写了 18 - 16 = 2 bit
            last_char = s[-_sage_const_2 ] # 倒数第二个字符
            char_idx = base64_chars.index(last_char)
            # 取低 2 位
            bits = f"{char_idx:06b}"[-_sage_const_2 :]
            bin_str += bits
            
    # 3. 将提取出的二进制串转换为字符
    print(f"[*] 提取到的二进制位长度: {len(bin_str)}")
    
    flag_bytes = b""
    for i in range(_sage_const_0 , len(bin_str), _sage_const_8 ):
        byte_chunk = bin_str[i:i+_sage_const_8 ]
        if len(byte_chunk) == _sage_const_8 :
            flag_bytes += bytes([int(byte_chunk, _sage_const_2 )])
            
    print("-" * _sage_const_30 )
    print("HIDDEN FLAG:")
    print(flag_bytes.decode(errors='ignore'))
    print("-" * _sage_const_30 )

# ==========================================
# 将此函数放在刚才的 solve() 中调用
# ==========================================
# 在 solve() 函数最后，不要直接 base64.b64decode(rsa_recovered_bytes)
# 而是调用 solve_stego(rsa_recovered_bytes)

def solve():
    print("[*] 正在读取 HUB1 和 HUB2...")
    
    # 读取文件逻辑（保持不变）
    try:
        with open("HUB1", "r") as f:
            content1 = f.read().split()
            N = Integer(content1[_sage_const_0 ])
            e1 = Integer(content1[_sage_const_1 ])
            c1_list = [Integer(x) for x in content1[_sage_const_2 :] if x.strip()]

        with open("HUB2", "r") as f:
            content2 = f.read().split()
            e2 = Integer(content2[_sage_const_1 ])
            c2_list = [Integer(x) for x in content2[_sage_const_2 :] if x.strip()]
    except Exception as e:
        print(f"[-] 读取文件出错: {e}")
        return

    # 检查互质
    g, s1, s2 = xgcd(e1, e2)
    if g != _sage_const_1 :
        print("[-] e1 和 e2 不互质，攻击无法进行！")
        return

    print("[*] 开始解密...")
    rsa_recovered_bytes = b"" 

    # 逐块解密
    for c1, c2 in zip(c1_list, c2_list):
        v1 = power_mod(c1, s1, N)
        v2 = power_mod(c2, s2, N)
        m = (v1 * v2) % N
        
        # 【关键修复】
        # 这里使用 long_to_bytes 得到的一定是 bytes 类型
        chunk = long_to_bytes(m)
        
        # 【针对前导零丢失的补丁】
        # 你的加密脚本是 read(255)，如果还原出来的不足 255 且不是最后一块，
        # 说明丢失了前导零 \x00。
        # 但如果是文本文件（Base64），通常不会以 \x00 开头，所以这里先不强行补零。
        rsa_recovered_bytes += chunk

    # ==========================================
    # 调试环节：先看一眼解密出来的是什么鬼
    # ==========================================
    print("\n" + "-"*_sage_const_30 )
    print("【调试信息】RSA 解密结果前 100 个字符：")
    print("-"*_sage_const_30 )
    
    # 打印原始字节的十六进制表示，看看是不是乱码
    print(f"Hex: {rsa_recovered_bytes[:_sage_const_20 ].hex()} ...")
    solve_stego(rsa_recovered_bytes)
    
    # 尝试作为文本打印，看看是不是像 Base64 (A-Z, a-z, 0-9, +, /)
    try:
        preview = rsa_recovered_bytes[:_sage_const_100 ].decode('ascii')
        print(f"Text: {preview}")
        
        # 简单的启发式检查
        import re
        if re.match(r'^[A-Za-z0-9+/=\s]+$', preview):
            print("==> 看起来像是有效的 Base64 字符串！")
        else:
            print("==> 警告：包含非 Base64 字符，RSA 解密可能出错了！")
            
    except UnicodeDecodeError:
        print("==> 警告：无法解码为 ASCII，说明解密结果是二进制乱码！")

    # ==========================================
    # 尝试 Base64 解码
    # ==========================================
    print("\n[*] 正在尝试 Base64 解码...")
    try:
        # 在 Python 3 中，b64decode 对于错误的 padding 极其敏感
        # 这是一个常见的 trick：手动补全 padding
        missing_padding = len(rsa_recovered_bytes) % _sage_const_4 
        if missing_padding:
            rsa_recovered_bytes += b'=' * (_sage_const_4  - missing_padding)
            
        final_flag = base64.b64decode(rsa_recovered_bytes)
        
        print("\n" + "="*_sage_const_30 )
        print("FINAL FLAG:")
        # 尝试 decode 为 utf-8 显示，如果不行直接显示 bytes
        try:
            print(final_flag.decode())
        except:
            print(final_flag)
        print("="*_sage_const_30 )
        
    except Exception as e:
        print(f"[-] Base64 解码最终失败: {e}")
        print("建议检查上面打印的【调试信息】，如果是乱码，说明共模攻击本身算错了。")

solve()

